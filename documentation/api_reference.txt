VoidRay Game Engine - API Reference
===================================

This document provides detailed documentation for all VoidRay classes and methods.

CORE CLASSES
============

Engine
------
The main engine class that manages the game loop and systems.

Constructor:
    Engine(width=800, height=600, title="VoidRay Game", fps=60)
    
    Parameters:
    - width (int): Screen width in pixels
    - height (int): Screen height in pixels
    - title (str): Window title
    - fps (int): Target frames per second

Methods:
    set_scene(scene: Scene)
        Set the current active scene.
    
    run()
        Start the main game loop. Blocks until game exits.
    
    stop()
        Stop the engine and exit the game loop.
    
    get_fps() -> float
        Get the current frames per second.
    
    get_delta_time() -> float
        Get the time elapsed since last frame in seconds.

Properties:
    width, height (int): Screen dimensions
    running (bool): Whether the game loop is active
    current_scene (Scene): Currently active scene
    input_manager (InputManager): Input handling system
    physics_engine (PhysicsEngine): Physics simulation system
    audio_manager (AudioManager): Audio playback system
    asset_loader (AssetLoader): Asset loading system
    renderer (Renderer): Rendering system

GameObject
----------
Base class for all game objects.

Constructor:
    GameObject(name="GameObject")
    
    Parameters:
    - name (str): Identifier for this object

Methods:
    update(delta_time: float)
        Update this object. Override in subclasses.
    
    render(renderer)
        Render this object. Override in subclasses.
    
    add_child(child: GameObject)
        Add a child object.
    
    remove_child(child: GameObject)
        Remove a child object.
    
    get_child(name: str) -> GameObject or None
        Find a child by name.
    
    add_tag(tag: str)
        Add a tag to this object.
    
    remove_tag(tag: str)
        Remove a tag from this object.
    
    has_tag(tag: str) -> bool
        Check if this object has a specific tag.
    
    get_world_position() -> Vector2
        Get world position including parent transforms.
    
    get_world_scale() -> Vector2
        Get world scale including parent transforms.
    
    get_world_rotation() -> float
        Get world rotation including parent transforms.
    
    destroy()
        Mark for destruction and remove from parent/scene.

Properties:
    name (str): Object identifier
    active (bool): Whether object is active
    transform (Transform): Position, rotation, and scale
    parent (GameObject): Parent object (None if root)
    children (list): List of child objects
    scene (Scene): Scene this object belongs to
    tags (list): List of string tags

Scene
-----
Manages collections of GameObjects.

Constructor:
    Scene(name="Scene")
    
    Parameters:
    - name (str): Scene identifier

Methods:
    on_enter()
        Called when scene becomes active. Override in subclasses.
    
    on_exit()
        Called when scene is deactivated. Override in subclasses.
    
    update(delta_time: float)
        Update all objects in scene.
    
    render(renderer)
        Render all objects in scene.
    
    add_object(obj: GameObject)
        Add an object to this scene.
    
    remove_object(obj: GameObject)
        Remove an object from this scene.
    
    find_object(name: str) -> GameObject or None
        Find an object by name.
    
    find_objects_with_tag(tag: str) -> list
        Find all objects with a specific tag.
    
    clear()
        Remove all objects from scene.

Properties:
    name (str): Scene identifier
    engine (Engine): Reference to the engine
    objects (list): List of all objects in scene
    active (bool): Whether scene is active

GRAPHICS CLASSES
===============

Sprite
------
A GameObject that can display images.

Constructor:
    Sprite(name="Sprite", image_path=None)
    
    Parameters:
    - name (str): Sprite identifier
    - image_path (str): Optional path to image file

Methods:
    load_image(image_path: str)
        Load an image from file.
    
    create_colored_rect(width: int, height: int, color: tuple)
        Create a simple colored rectangle.
    
    set_color(color: tuple)
        Set color tint (RGB tuple).
    
    set_alpha(alpha: int)
        Set transparency (0-255).
    
    get_size() -> Vector2
        Get sprite dimensions.
    
    get_rect() -> pygame.Rect
        Get bounding rectangle.

Properties:
    surface (pygame.Surface): The sprite's image
    color (tuple): Current color tint
    alpha (int): Current transparency
    visible (bool): Whether sprite is rendered

Renderer
--------
Handles all drawing operations.

Methods:
    clear(color=None)
        Clear screen with specified color.
    
    present()
        Display the rendered frame.
    
    draw_sprite(surface, position, rotation=0, scale=None)
        Draw a sprite at specified position.
    
    draw_rect(position, size, color, filled=True)
        Draw a rectangle.
    
    draw_circle(center, radius, color, filled=True)
        Draw a circle.
    
    draw_line(start, end, color, width=1)
        Draw a line between two points.
    
    draw_text(text, position, color=WHITE, font_size=24, font_name=None)
        Draw text at specified position.
    
    world_to_screen(world_pos) -> Vector2
        Convert world coordinates to screen coordinates.
    
    screen_to_world(screen_pos) -> Vector2
        Convert screen coordinates to world coordinates.

Camera
------
Controls the view of the game world.

Constructor:
    Camera(name="Camera")

Methods:
    set_target(target: GameObject, offset=None)
        Set object for camera to follow.
    
    set_bounds(min_pos: Vector2, max_pos: Vector2)
        Set camera movement limits.
    
    shake(intensity: float, duration: float)
        Add camera shake effect.
    
    world_to_screen(world_pos, screen_size) -> Vector2
        Convert world position to screen position.
    
    screen_to_world(screen_pos, screen_size) -> Vector2
        Convert screen position to world position.

Properties:
    target (GameObject): Object to follow
    follow_speed (float): Speed of camera following
    offset (Vector2): Offset from target position

INPUT CLASSES
============

InputManager
-----------
Centralized input handling system.

Methods:
    # Keyboard
    is_key_pressed(key: int) -> bool
        Check if key is currently held down.
    
    is_key_just_pressed(key: int) -> bool
        Check if key was just pressed this frame.
    
    is_key_just_released(key: int) -> bool
        Check if key was just released this frame.
    
    get_axis(negative_key: int, positive_key: int) -> float
        Get axis value (-1 to 1) from two keys.
    
    get_movement_vector() -> Vector2
        Get movement from WASD/arrow keys.
    
    # Mouse
    is_mouse_button_pressed(button: int) -> bool
        Check if mouse button is held down.
    
    is_mouse_button_just_pressed(button: int) -> bool
        Check if mouse button was just pressed.
    
    is_mouse_button_just_released(button: int) -> bool
        Check if mouse button was just released.
    
    get_mouse_position() -> Vector2
        Get current mouse position.
    
    get_mouse_world_position(camera) -> Vector2
        Get mouse position in world coordinates.

Keys
----
Constants for common key codes:
    A, B, C, ..., Z: Letter keys
    NUM_0, NUM_1, ..., NUM_9: Number keys
    SPACE, ENTER, ESCAPE, BACKSPACE, TAB: Special keys
    SHIFT, CTRL, ALT: Modifier keys
    LEFT, RIGHT, UP, DOWN: Arrow keys
    F1, F2, ..., F12: Function keys

MouseButtons
-----------
Constants for mouse buttons:
    LEFT, MIDDLE, RIGHT: Mouse buttons
    WHEEL_UP, WHEEL_DOWN: Mouse wheel

PHYSICS CLASSES
==============

PhysicsEngine
------------
Core physics simulation system.

Methods:
    add_collider(collider: Collider)
        Add collider to physics simulation.
    
    remove_collider(collider: Collider)
        Remove collider from physics simulation.
    
    query_point(point: Vector2) -> list
        Find all colliders containing a point.
    
    query_area(center: Vector2, radius: float) -> list
        Find all colliders within circular area.
    
    raycast(start: Vector2, direction: Vector2, max_distance=inf) -> Collider
        Cast ray and return first collider hit.

Properties:
    gravity (Vector2): Global gravity force

Collider
--------
Base class for collision shapes.

Properties:
    game_object (GameObject): Attached game object
    is_trigger (bool): If True, doesn't resolve collisions
    is_static (bool): If True, doesn't move during collision
    velocity (Vector2): Current velocity
    on_collision (function): Callback for collision events

RectCollider
-----------
Rectangular collision shape.

Constructor:
    RectCollider(game_object=None, width=32, height=32, offset=None)

Properties:
    width, height (float): Rectangle dimensions
    offset (Vector2): Offset from game object position

CircleCollider
-------------
Circular collision shape.

Constructor:
    CircleCollider(game_object=None, radius=16, offset=None)

Properties:
    radius (float): Circle radius
    offset (Vector2): Offset from game object position

AUDIO CLASSES
============

AudioManager
-----------
Manages all audio playback.

Methods:
    load_sound(name: str, file_path: str)
        Load a sound effect from file.
    
    play_sound(name: str, volume=1.0, loops=0)
        Play a loaded sound effect.
    
    stop_sound(name: str)
        Stop a playing sound.
    
    load_music(file_path: str)
        Load background music.
    
    play_music(file_path=None, loops=-1, fade_in=0)
        Play background music.
    
    stop_music(fade_out=0)
        Stop background music.
    
    set_music_volume(volume: float)
        Set music volume (0.0-1.0).
    
    set_sfx_volume(volume: float)
        Set sound effects volume (0.0-1.0).

MATH CLASSES
===========

Vector2
-------
2D vector mathematics.

Constructor:
    Vector2(x=0, y=0)

Methods:
    magnitude() -> float
        Get vector length.
    
    normalized() -> Vector2
        Get unit vector in same direction.
    
    dot(other: Vector2) -> float
        Calculate dot product.
    
    distance_to(other: Vector2) -> float
        Calculate distance to another vector.
    
    rotate(angle_radians: float) -> Vector2
        Rotate vector by angle.
    
    lerp(other: Vector2, t: float) -> Vector2
        Linear interpolation to another vector.

Static Methods:
    Vector2.zero(), Vector2.one()
    Vector2.up(), Vector2.down(), Vector2.left(), Vector2.right()
    Vector2.from_angle(angle_radians, magnitude=1.0)

Operators:
    +, -, *, /: Standard math operations
    ==: Equality comparison

Transform
---------
Represents position, rotation, and scale.

Constructor:
    Transform(position=None, rotation=0, scale=None)

Methods:
    translate(offset: Vector2)
        Move by offset.
    
    rotate(angle_degrees: float)
        Rotate by angle.
    
    look_at(target: Vector2)
        Rotate to face target position.
    
    transform_point(local_point: Vector2) -> Vector2
        Convert local point to world space.

Properties:
    position (Vector2): Object position
    rotation (float): Object rotation in degrees
    scale (Vector2): Object scale factors

ASSET MANAGEMENT
===============

AssetLoader
----------
Centralized asset loading and caching.

Methods:
    load_image(name: str, filename: str) -> pygame.Surface
        Load and cache an image.
    
    get_image(name: str) -> pygame.Surface
        Get a loaded image by name.
    
    load_sound(name: str, filename: str) -> pygame.mixer.Sound
        Load and cache a sound.
    
    get_sound(name: str) -> pygame.mixer.Sound
        Get a loaded sound by name.
    
    preload_assets(asset_list: dict)
        Load multiple assets from configuration.

COMMON COLOR CONSTANTS
=====================
Available in voidray.graphics.renderer.Color:
    WHITE, BLACK, RED, GREEN, BLUE
    YELLOW, CYAN, MAGENTA
    GRAY, LIGHT_GRAY, DARK_GRAY

EXAMPLE USAGE PATTERNS
=====================

Basic Game Loop:
```python
class MyScene(Scene):
    def on_enter(self):
        # Create game objects
        player = Player()
        self.add_object(player)
    
    def update(self, delta_time):
        super().update(delta_time)
        # Game logic here
    
    def render(self, renderer):
        super().render(renderer)
        # Custom drawing here
